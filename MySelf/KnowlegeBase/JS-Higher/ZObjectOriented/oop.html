<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>面向对象</title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		//万物皆对象
		//对象的定义,三种方式：
//		var obj1={
//			name:"lala",
//			age:18
//		};
		
		//属性或者方法定义在原型上的；
		//对象的原型是__proto__;
		//对象是由它本身和它的原型公共构成的
//		var obj3=Object.create({name:"la",age:20});
//		console.log(obj1);
//		console.log(obj3);
		//php对象的调用方式 "->"
		
		//直接定义对象；
		//追加定义对象；
//		var obj2=new Object();
//		obj2.age="20";
//		obj2.name="lala";
//		console.log(obj2);
		//覆盖定义对象
//		obj2={
//			height:"160cm",
//			hobby:function(){
//				console.log("喜欢篮球");
//			}
//		};
//		console.log(obj2);
		//json串格式规范：外面单引号  里面双引号
//		var jsons='{"name":"lala","age":"19"}';
		
		//对象转换json串、数组转json串
//		var json1=JSON.stringify(obj2);
//		console.log(json1);
		//json数据转换成对象
//		var newObj=JSON.parse(json1);
//		console.log(newObj);
		
		//传值和传址的问题
		//传值
		// var a=10;
		// var b=a;
		// b=5;
		// console.log(a);
		
		//传址:对象赋值取相同的内存地址
		//复杂的数据类型传址
		// var obja={
		// 	a:10
		// };
		// var objb=obja;
		// objb.a=5;
		// console.log(obja.a);
		
		//传址(浅拷贝)
		// var arr=[1,2,3,4,5];
		// var arr2=arr;
		// arr2[1]=6;
		// console.log(arr);

		//深拷贝；通过转json串再转数组
		// var arr3=JSON.stringify(arr);
		// console.log(arr3);
		// arr3[1]=6;
		// console.log(arr);
		
		
//		var
		//------es6-------
//		const
//		let的作用域{}
		// let只在作用域有效果,区分作用域
		// var 整个作用域有效果,只有一层作用域
		// {
		// 	let a=10;
		// 	var b=15;
		// 	console.log(a,b);
		// }
		// console.log(b);
		// console.log(a);
		
		//常量：不能被重复定义 es6;
//		const PI="3.14159265358979323846";
//		console.log(PI);
//		const PI="3.14";
//		console.log(PI);
		
		//模板字符串
//		let name="张三";
		//es5写法
//		let str="姓名是："+name+"年龄是19";
//		console.log(str);
		//es6写法
//		let str2=`姓名是: ${name}年龄是19`;
//		console.log(str2);

		//es6 对象

		// var name="张三";
		// var pwd="123";
		//es5
//		var obj={
//			name:name,
//			pwd:pwd
//		};
//		console.log(obj);
		
		//es6
		// var obj2={
		// 	name,
		// 	pwd
		// };
		// console.log(obj2);
		
		//es5
//		var dog={
//			name:"大黄",
//			sex:"男",
//			action:function(){
//				console.log("吃hahahahahh");
//			}
//		};

		//es6,简写function
//		var dog={
//			name:"大黄",
//			sex:"男",
//			action(){
//				console.log("吃hahahahahh");
//			}
//		};
//		console.log(dog);
		//调用属性
//		console.log(dog.name);
		//调用方法
//		dog.action();
		
		//工厂模式,防止变量污染
//		function Factory(name,sex){
//			//obj人类
//			var obj={};
//			obj.name=name;
//			obj.sex=sex,
//			obj.hobby=function(){
//				console.log("我喜欢喝水");
//			}
//			return obj;
//		}
//		var obj3=Factory("nana","女");
//		console.log(obj3);
//		obj3.hobby();
		//练习：
//		function dog(){
//			var obj={};
//			obj.name="大黄";
//			obj.sex="男",
//			obj.action=function(){
//				console.log("吃、撒欢、叫");
//			}
//			return obj;
//		}
//		var dog=dog();
//		dog.action();
//		console.log(dog);
		//es6:箭头函数；（自带return）
		//es5,有参函数
//		function test(str){
//			return str;
//		}
		//es5，无参函数
//		function test1(){
//			var str="lala";
//			return str;
//		}
		//es6,箭头函数,必须是匿名函数,无参,加上{}就不自带return
//		var test=(str)=>str;
		//es6,无参箭头函数,返回对象，加上小括号."{}"作用域和对象冲突情况----------------------
//		var test3=()=>({
//			var str="lalasasas";
//			return str;
//			name:"lala",
//			age:19
//		});
//		console.log(test3());
		//es6
//		var str="hello";
//		setTimeout(()=>{
//			console.log(str);
//		});


		//this穿透,穿透上一层
		// var obj={
		// 	name:"张三",
		// 	age:18,
			// action:function(){
			// 	console.log(this);
			// }
			//箭头函数写法：this穿透--------------------
			// action:()=>{
			// 	console.log(this);
			// }
		// };
		// obj.action();
		
		
		//构造函数；类似于类的概念;
		//约定俗成：首字母大写;
		//定义构造函数;
//		function Dog(name,sex){
//			this.name=name;
//			this.sex=sex;
//			this.action=function(){
//				console.log("吃、喝、撒欢");
//			}
//		}
		//调用构造函数
		//实例化 关键字：new(把抽象类具体化,把类变成对象);
//		var dahuang=new Dog("大黄","男");
//		var xiaohei=new Dog("小黑","男");
//		console.log(dahuang,xiaohei);
//		dahuang.action();
		
		//构造函数练习：汽车
//		function Car(num,color){
//			this.num=num;
//			this.color=color;
//			this.run=function(){
//				console.log("每秒跑500米");
//			}
//		}
//		var myCar=new Car("666","red");
//		console.log(myCar.num,myCar.color);
//		myCar.run();
		//new具体做了什么？三件事：
		//1.创建一个空的对象---------------
//		var obj={};
		//2.改变this的指向 call() apply() bind();-------------
//		function test(name,age){
//			console.log(name,age);
//			console.log(this);
//		}
//		var obj={
//			name:"张三",
//			age:19
//		};
//		test.call(obj,"lala",18);
//		test.apply(obj,["lala",20]);
//		test.bind(obj)("lala",30);
//		Car.call(obj,"x6","red");
//		console.log(obj.num);
		//3.赋值原型--------------
//		obj.__proto__=Car.prototype;
		
		//构造函数的原型
		//对象是由自身和原型共同构成的；对象的原型__proto__
		//构造函数是由自身和原型共同构成的;构造函数的原型prototype
		//属性写在构造函数里，方法写在原型上
//		function Person(name,age,height){
//			this.name=name;
//			this.age=age;
//			this.height=height;
//		}
		//Person.prototype也是一个对象,追加方式添加，否则会覆盖
//		Person.prototype.action=function(){
			//this指向实例化对象
//			console.log(this);
//			console.log(this.name+"在操场跑步");
//		}
//		Person.prototype.hobby=function(){
//			console.log(this);
//			console.log("我喜欢篮球");
//		}
//		var zhangsan=new Person("lala",19,"178cm");
//		zhangsan.action();
		
		//__proto__和prototype对比
		// function Person(name){
		// 	this.name=name;
		// }
		// var newPerson=new Person("lala");
		// console.log(Person.prototype===newPerson.__proto__);
		
		//通过原型找到构造函数本身
		// function Person(name){
		// 	this.name=name;
		// }
		// console.log(Person.prototype.constructor);
//		var newPerson=new Person("lala");
//		console.log(newPerson);
		
		//类的特性: 封装、继承、多态、重载
		//封装:-----
		//共有、私有属性
//		function Person(name){
			//私有属性,实例化对象访问不到
//			var name=name;
			//公有属性，实例化对象和构造函数都可以访问到
//			this.height="179cm";
			//get方法：通过公有方法访问私有属性
//			this.get=function(){
//				return name;
//			}
			//set方法：设置私有属性
//			this.set=function(newName){
//				name=newName;
//			}
//		}
//		var newPerson=new Person("lala");
//		console.log(newPerson.get());
//		console.log(newPerson.height);
//		newPerson.set("hgahalala");
//		console.log(newPerson.get());
		//继承：-----
		//es5:
//		function Dad(height){
//			this.name="张三";
//			this.age=50;
//			this.height=height;
//			this.money="$1000000";
//			this.hobby=function(){
//				console.log("喜欢太极");
//			}
//		}
//		function Son(height){
//			Dad.call(this,height);
//			this.action=function(){
//				console.log("玩玩玩");
//			}
//		}
//		var newSon=new Son("180cm");
//		newSon.hobby();
//		console.log(newSon.height);
//		newSon.action();
		//定义一个人类：定义一个学生类：学生类继承人类；call apply bind;
// 		function Human(name,age){
// 			this.name=name;
// 			this.age=age;
// 			this.hobby=function(){
// 				console.log("我是人类的方法");
// 			}
// 		}
// 		Human.prototype.run=function(){
// 			console.log("run方法");
// 		}
// 		function Student(name,age){
// //			Human.call(this,name,age);
// //			Human.apply(this,[name,age]);
// 			Human.bind(this)(name,age);
// 			this.action=function(){
// 				console.log("我是学生的方法");
// 			}
// 		}
		//子级继承父级的原型内容，涉及到传址的问题
//		Student.prototype=Human.prototype;
		//解决传址问题:创建一个空的构造方法，去装父级的原型
		// function Link(){}
		// Link.prototype=Human.prototype;//新开辟一块内存去装父级的原型内容,重写方法不会影响父级的原型内容
		// Student.prototype=new Link();//只有原型的内容，没有自己的东西
		//重写子级的方法会影响父级
		// Student.prototype.run=function(){
		// 	console.log("重写run方法");
		// }
		
		//实例化子级
		// var newStudent=new Student("周娜",18);
//		newStudent.hobby();
//		console.log(newStudent.name,newStudent.age);
//		newStudent.action();
// 		newStudent.run();
		//实例化父级
		// var newHuman=new Human("lala",20);
		// newHuman.run();
		
		// const mySet=new Set();
		let arr=[1,5,2,3,2,5];
		// for(var i=0;i<arr.length;i++){
		// 	mySet.add(arr[i]);
		// }
		// arr.forEach(x => mySet.add(x));
		// console.log(arr,mySet);

		var newArr=new Set(arr);
		console.log(newArr);

		

	</script>
</html>
