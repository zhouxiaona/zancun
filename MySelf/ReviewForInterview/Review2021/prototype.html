<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }

    .borderOut {
        width: 100px;
        height: 100px;
        background: lightblue;
        margin-top: 20px;
    }

    .borderInner {
        width: 50%;
        height: 50px;
        background: pink;
        margin-top: 10px;
        margin-left: 10px;
    }
</style>

<body>
    <div class="borderOut">
        <div class="borderInner"></div>
    </div>
</body>
<script>
    /**
     * 一.构造函数-原型-实例
     * 1，函数都有prototype属性，原型属性；
     * 2，实例对象(除null)都有_proto_属性，指向该对象的原型；
     * 3，函数的原型对象上有constrctor指向原型的构造函数；
     * 4，Function.prototype._proto_ = null
    */

    /**
     * 二，继承
     *
     * 1，原型链继承：子类的原型指向父类的实例；
     *    1-父类引用类型的属性被所有实例共享；
     *    2-创建子类时不能向父类传递参数；
     *
     * 2，构造函数继承：在子类构造函数中把父类this指向子类；
     *    1-避免了父类引用类型数据被所有实例进行共享；
     *    2-可以向父类构造函数进行传参；
     *    3-方法都在构造函数中进行，每次创建实例都会创建一遍方法;
     *
     * 3，组合继承
     *    1-
     *
     * **/

    // function Parent(name) {
    //     this.name = name;
    //     this.colors = ['red', 'blue', 'green'];
    // }
    // Parent.prototype.getName = function () {
    //     console.log(this.name)
    // }

    // function Child(name, age) {
    //     Parent.call(this, name);
    //     this.age = age;
    // }
    // Child.prototype = new Parent();
    // Child.prototype.constructor = Child;

    // var child1 = new Child('kevin', '18');
    // child1.colors.push('black');

    // console.log(child1.name); // kevin
    // console.log(child1.age); // 18
    // console.log(child1.colors); // ["red", "blue", "green", "black"]

    // var child2 = new Child('daisy', '20');
    // console.log(child2.name); // daisy
    // console.log(child2.age); // 20
    // console.log(child2.colors); // ["red", "blue", "green"]

    // var a = { n: 1 };
    // a.x = a = { n: 2 };
    // console.log(a.x, '---a.x---');

    // function deepClone(obj) {
    //     if (obj === null) return obj;
    //     if (obj instanceof Date) return new Date(obj)
    //     if (obj instanceof RegExp) return new RegExp(obj)
    //     if (typeof obj !== 'object') return object;
    //     let cloneObj = new obj.constructor();
    //     for (let key in obj) {
    //         if (obj.hasOwnProperty(key)) {
    //             cloneObj[key] = deepClone(obj[key])
    //         }
    //     }
    //     return cloneObj;
    // }

    // 浅拷贝: 引用类型对象指向同一块内存地址，所以值相等;
    /*
        slice(start(包括),end(不包括))
        substr(start(包括),length)
        substring(start(包括),stop(不包括))
    */
    // let obj1 = { person: { name: "kobe", age: 41, detail: { g: 1 } }, sports: 'basketball' };
    // let obj2 = Object.assign({}, obj1);
    // obj2.person.name = "wade";
    // obj2.sports = 'football'
    // console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }
    // console.log(obj1.person == obj2.person)

    // let arr = [1, 2, 3, 4, 5]
    // try {
    //     arr.forEach((item, index) => {
    //         if (item >= 3) throw new Error('end');
    //         console.log(item)
    //     })
    // } catch (err) {
    //     console.log(err, '--err--')
    // }

    // if (arr[2] <= 3) return;
    // console.log(arr[a], '--arr[a]--')
    // console.log(arr, '--arr--')

    // function foo() {
    //     console.log(a, 'a1');
    //     var a = 1;
    //     console.log(a, 'a2');
    //     function a() { }
    //     console.log(a, 'a3');
    // }
    // foo();

    function deepClone(obj, map = new Map()) {
        if (obj instanceof Object) {
            if (obj instanceof Function) return obj;
            if (obj instanceof Date) return new Date(obj);
            if (obj instanceof RegExp) return new RegExp(obj);
            // 解决循环引用
            if (map.has(obj)) return map.get(obj);
            // 拷贝原型链
            let allDesc = Object.getOwnPropertyDescriptors(target);
            let cloneObj = Object.create(Object.getPrototypeOf(target), allDesc);
            map.set(obj, cloneObj);
            // Reflect.ownKeys可以拿到不可枚举属性和symbol类型的键名
            for (let key of Reflect.ownKeys(obj)) {
                cloneObj[key] = deepClone(obj[key], map);
            }
            return cloneObj
        } else {
            return obj;
        }
    }






</script>

</html>