<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Javascript</title>
</head>

<body>
  <!-- box-sizing:border-box;
      宽度为width = Math.Max(padding-left + border-left + padding-right + border-right, width)
  -->
  <!-- box-sizing:content-box;/padding-box;
      宽度为width = border-left + padding-left + width + padding-right + border-right
  -->
  <!-- Interview: 如何用html和css实现随移动端自适应的正方形:
    1.width=height=20vw;2.height=0;width=20vw;padding-bottom=20vw;-->
  <!-- <div class="box"></div> -->
</body>
<script>
  // 1.判断对象的数据类型：
  // let obj ={a:1, b:2}
  // let arr = [1,2,3]
  // let str = '123'
  // let func=function(){}
  // console.log(Object.prototype.toString.call(obj)) //[object Object]
  // console.log(Object.prototype.toString.call(arr)) // [object Array]
  // console.log(Object.prototype.toString.call(str)) //[object String]
  // console.log(Object.prototype.toString.call(func)) //[object Function]

  // 2.判断一个对象是否是空对象的函数
  // function isEmptyObject(obj){
  //     console.log(JSON.stringify(obj))
  //     for(let k in obj){
  //         return false
  //     }
  //     return true
  // }
  // console.log(isEmptyObject(obj),isEmptyObject({}))
  // js判断一个对象是否是空对象
  // 1. 
  // function isEmpty(obj) {
  //   for (let i in obj) {
  //     return false
  //   }
  //   return true
  // }
  // 2.
  // function isEmpty2(obj) {
  //   if (JSON.stringify(obj) === '{}') return true
  //   return false
  // }
  // 3.
  // function isEmpty3(obj) {
  //   if (Object.keys(obj).length == 0) return true
  //   return false
  // }
  // console.log(isEmpty3({}), 'empty')
  // console.log(isEmpty3({ a: 1, b: 2 }))

  // 3.循环实现数组map方法,（高阶函数）必须return,返回一个新处理后的数组，不改变原数组
  //    let mapArr=[1,2,3,4,4,3,2,5,6]
  //    let testMapArr=mapArr.map((val,key,arr)=>{
  //     console.log(val,key,arr)
  //     // return val+=1
  //    })
  //    console.log(mapArr,testMapArr)

  //    function myMap(fn, context){
  // console.log(context,'--context--',this)
  //         // console.log(Array.prototype.slice,'--prototype--',this)
  //         let myArr = Array.prototype.slice.call(this) // 类数组（具有length属性）转化成普通数组
  //         // console.log(myArr)
  //         let newArr = []
  //         for(let i=0;i<myArr.length;i++){
  //             if(!myArr.hasOwnProperty(i)) continue; // 避免稀疏数组(压缩后的数组000001100)
  //             // console.log(myArr.hasOwnProperty()) // 检测对象中是否含有某个属性的方法
  //             newArr[i]=fn.call(context,myArr[i],i,this)
  //         }
  //         return newArr
  //    } 
  //    Array.prototype.myMap = myMap

  //    console.log([1,2,3].myMap(function(arg){
  //        console.log(arg,'ll')
  //        return 1 
  //    }))

  // 3.数组中reduce方法的使用：必须有return值，否则为undefined，
  // 四个参数prev,next,index,arr,不改变原数组
  // let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
  // 3-1.计算数组中每个元素出现的次数
  // let newName = names.reduce((pre,cur,index,arr)=>{
  //     // console.log(pre,cur,index,arr)
  //     if(cur in pre){ //判断对象中是否含有某个属性名
  //         pre[cur] += 1
  //     }else{
  //         pre[cur] = 1
  //     }
  //     return pre;
  // },{})
  // console.log(newName,'--',names)
  // 3-2.数组去重
  // let newNames1 = names.reduce((pre,cur,index,arr)=>{
  //     if(!pre.includes(cur)){
  //         pre.push(cur)
  //     }
  //     return pre
  // },[])
  // console.log(newNames1,names)
  // 3-3.对象里的属性求和
  // var result = [
  //     {
  //         subject: 'math',
  //         score: 10
  //     },
  //     {
  //         subject: 'chinese',
  //         score: 20
  //     },
  //     {
  //         subject: 'english',
  //         score: 30
  //     }
  // ];
  // let sum = result.reduce((pre,cur)=>{
  //     return pre+=cur.score
  // },0)
  // console.log(sum)

  // 4.数组扁平化,arr.flat(Infinity),实现数组扁平化
  // let lala = [1,2,3,4,[3,4,3,5],5,[5,6,4,3,[1,2,6,7]]]
  // let res = lala.flat(Infinity)
  // console.log(res)
  // 4-1：携程面试题：编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
  // https://blog.csdn.net/u010080803/article/details/98967063
  // var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
  // function myFlat(arr){
  //     return arr.reduce((prev,next)=>{
  //         return prev.concat(Array.isArray(next)?myFlat(next):next)
  //     },[])
  // }
  // console.log(myFlat(arr))
  // 解决办法，Array.from()把new Set()的数组集合转换成数组，使用sort()函数进行排序
  // Array.from()方法就是把一个类数组对象或者可遍历对象转换成一个真正的数组
  // 1.类数组对象，具有length属性，没有length属性，=[]空数组
  // 2.属性名为数字或者字符串类型的数字
  // 3.将set结构的数据转换成真正的数组
  // 4.Array.from(arr,func),还可接受第二个参数，类似于map，对元素进行处理
  // 5.将字符串转换成数组
  let arrayLike = {
    '0': 'tom',
    '1': '65',
    '2': '男',
    '3': ['jane', 'john', 'Mary'],
    length: 4
  }
  let a = new Set([1, 2, 3, 4])
  console.log(Array.from(a).length, '---------------------')
  let arr = Array.from(arrayLike)
  console.log(arr)  // [ undefined, undefined, undefined, undefined ]
  console.log(Array.from({ length: 20 }, (v, k) => k += 1))
  // console.log(Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{return a-b}))
  // 4-2.arr.concat(arr2),此函数连接两个数组，返回一个新数组，不改变原来的两个数组
  // let arr1=[1,2,5,4,2,2,1]
  // let arr2=[2,3,2,1]
  // console.log(arr1.concat(arr2),'--',arr1,'--',arr2)
  // console.log(new Set(arr1))
  //    var module = {
  //         x: 42,
  //         getX: function() {
  //             console.log('this', this)
  //             return this.x;
  //         }
  //     }
  //     var test = module.getX
  //     console.log(test()) // window undefined
  //     console.log(module.getX()) // module 42

  //    使用for循环实现filter()
  // Array.prototype.myFilter=function(fn,context){
  //     let arr = Array.prototype.slice.call(this)
  //     let newArr = []
  //     for(let i = 0;i<arr.length;i++){
  //         if(!arr.hasOwnProperty(i)) continue;
  //         fn.call(context,arr[i],i,this) && newArr.push(arr[i])
  //     }
  //     return newArr;
  // }
  // console.log(names.myFilter((item,index)=>{
  //     return item === 'Alice'
  // }))

  // Array.prototype.selfFilter = function(fn,context){
  //     let arr = Array.prototype.slice.call(this)
  //     return arr.reduce((pre,cur,index)=>{
  //         return fn.call(context,cur,index,this)?[...pre,cur]:[...pre]
  //     },[])
  // }

  // Array.prototype.mySome = function(fn,context){
  //     let arr = Array.prototype.slice.call(this)
  //     if(!arr.length) return false;
  //     for(let i=0;i<arr.length;i++){
  //         if(!arr.hasOwnProperty(i)) continue;
  //         if(fn.call(context,arr[i],index,this)) return true;
  //     }
  //     return false;
  // }
  // Array.prototype.myEvery = function(fn,context){
  //     let arr = Array.prototype.slice.call(this)
  //     if(!arr.length) return true;
  //     for(let i=0;i<arr.length;i++){
  //         if(!arr.hasOwnProperty(i)) continue;
  //         if(!fn.call(context,arr[i],i,this)) return false;
  //     }
  //     return true
  // }

  // console.log([1,2,3,4,5,3,4,2].myEvery((item,index)=>{
  //     return item > 4
  // }))

  // let arrss = [1,2,3]
  // console.log(arrss.reduce((pre,cur,index,arrs)=>{
  //     console.log(pre,cur,index,arrs)
  //     return pre+=cur
  // }))

  // 循环实现reduce方法
  // Array.prototype.selfReduce = function(fn,initValue){
  //     let arr = Array.prototype.slice.call(this)
  //     let startIndex,
  //     res;
  //     if(initValue === undefined){
  //         for(let i=0;i<arr.length;i++){
  //             if(!arr.hasOwnProperty(i)) continue;
  //             startIndex = i;
  //             res = arr[i];
  //             break;
  //         }
  //     }else{
  //         res = initValue
  //     }

  //     for(let j = ++startIndex||0; j < arr.length; j++){
  //         if(!arr.hasOwnProperty(i)) continue;
  //         res = fn.call(null,res,arr[j],j,this)
  //     }
  //     return res;
  // }

  // Array.prototype.myReduce = function(fn,initValue){
  //     let arr = Array.prototype.slice.call(this)
  //     let startIndex,
  //     res;
  //     if(initValue === undefined){
  //         for(let i=0;i<arr.length;i++){
  //             if(!arr.hasOwnProperty(i)) continue;
  //             startIndex=i;
  //             res = arr[i]
  //             break;
  //         }
  //     }else{
  //         res = initValue
  //     }
  //     for(let i=++startIndex||0;i<arr.length;i++){
  //         if(!arr.hasOwnProperty(i)) continue;
  //         res = fn.call(null,res,arr[i],i,this)
  //     }
  //     return res;
  // }


  // console.log([1,2,3].myReduce((pre,cur,index)=>{
  //     return pre += cur
  // }))

  // Array.prototype.selfFlat = function(depth=1){
  //     let arr = Array.prototype.slice.call(this)
  //     if(depth === 0) return arr;
  //     return arr.reduce((pre,cur)=>{
  //         return Array.isArray(cur)?[...pre, ...selfFlat.call(cur,depth-1)]:[...pre, cur];
  //     },[])
  // }

  // Array.prototype.flats = function(depth=1){
  //     let arr = Array.prototype.slice.call(this)
  //     if(depth===0) return arr;
  //     return arr.reduce((pre,cur)=>{
  //         if(Array.isArray(cur)){
  //             return [...pre,...flats(cur,depth-1)]
  //         }else{
  //             return[...pre,cur]
  //         }
  //     },[])
  // }

  // let arrsss = [1,2,3,[2,3,4,[9,9,9]],[2,2,2]]
  // let newArr = arrsss.flats()
  // console.log(newArr)

  // 手动实现class语法
  // function inherit(subType,superType){
  //     subType.prototype=Object.create(superType.prototype,{
  //         constructor:{
  //             enumerable:false,
  //             configurable:true,
  //             writable:true,
  //             value:subType
  //         }
  //     })
  //     Object.setPrototypeOf(subType,superType)
  // }

  // function inherit(subType,superType){
  //     subType.prototype = Object.create(superType.prototype,{
  //         constructor:{
  //             enumerable:false,
  //             configurable:true,
  //             writable:true,
  //             value:subType
  //         }
  //     })
  //     Object.setPrototypeOf(subType,superType)
  // }

  // 函数柯里化
  // function curry(fn){
  //     // console.log(fn,'--fn--',fn.length) //第一个有默认值参数之前的形参个数
  //     if(fn.length<=1) return fn;
  //     const generator=(...args)=>{
  //         // console.log(args,'--args--')
  //         if(fn.length===args.length){
  //             return fn(...args)
  //         }else{
  //             return (...args2)=>{
  //                 console.log(args,'--args2--',args2)
  //                 return generator(...args,...args2)
  //             }
  //         }
  //     }
  //     return generator;
  // }
  // let add = (a,b,c,d) => a+b+c+d
  // let curriedAdd = curry(add)
  // // console.log(curriedAdd,'--curriedAdd--')
  // curriedAdd(1)(2)(3)(4)

  // function curry(fn){
  //     if(fn.length<=1)return fn;
  //     const generator = (...args)=>{
  //         if(args.length===fn.length){
  //             return fn(...args)
  //         }else{
  //             return(...args2)=>{
  //                 return generator(...args,...args2)
  //             }
  //         }
  //     }
  // }

  // 更优雅的处理try catch
  // async function errorCaptrue(asyncFunc){
  //     try{
  //         let res = await asyncFunc();
  //         return [null,res]
  //     }catch(err){
  //         return [err,null]
  //     }
  // }

  // let [err,res] = await errorCaptrue(asyncFunc)



  // call,apply,bind的区别
  // const arrss = [1,2,3,4,5,6]
  // const max = Math.max.apply(null, arrss)
  // console.log(max) 


  // 有只猫叫小黑，小黑会吃鱼
  // const cat = {
  //     name: '小黑',
  //     eatFish(...args) {
  //         console.log('this指向=>', this);
  //         console.log('...args', args);
  //         console.log(this.name + '吃鱼');
  //     },
  // }
  // // 有只狗叫大毛，大毛会吃骨头
  // const dog = {
  //     name: '大毛',
  //     eatBone(...args) {
  //         console.log('this指向=>', this);
  //         console.log('...args', args);
  //         console.log(this.name + '吃骨头');
  //     },
  // }

  // console.log('=================== call =========================');
  // 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃
  // cat.eatFish.call(dog, '汪汪汪', 'call')
  // 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃
  // dog.eatBone.call(cat, '喵喵喵', 'call')

  // console.log('=================== apply =========================');
  // cat.eatFish.apply(dog, ['汪汪汪', 'apply'])
  // dog.eatBone.apply(cat, ['喵喵喵', 'apply'])

  // console.log('=================== bind =========================');
  // 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃
  // const test1 = cat.eatFish.bind(dog, '汪汪汪', 'bind')
  // const test2 = dog.eatBone.bind(cat, '喵喵喵', 'bind')
  // test1()
  // test2()

  // js中继承的几种方法：
  // 原型链继承-借用构造函数继承-组合继承-原型式继承-寄生式继承-寄生组合式继承-ES6 extends继承
  // function Person(name){ //给构造函数添加参数
  //     this.name=name
  //     this.sum=function(){
  //         alert(this.name)
  //     }
  // }
  // Person.prototype.age=10 // 给构造函数添加了原型属性
  // // 原型链继承：
  // function Per (){
  //     this.name='lala'
  //     // this.age=20
  // }
  // Per.prototype=new Person() // 让新实例的原型等于父类的实例
  // function Per2(){
  //     this.name="xixi"
  // }
  // Per2.prototype=new Person()
  // // instanceof 判断一个元素是否在另一个元素的原型链上
  // let per1 = new Per()
  // let per2 = new Per2()
  // console.log(per1.age)
  // per1.prototype.age = 222
  // console.log(per2.age)

  // console.log(per1.name)
  // console.log(per1 instanceof Person)
  // per1.sum()
  //特点： 实例可继承：  实例的构造函数属性，父类的构造函数属性，父类原型的属性(新实例不会继承父类实例的属性)
  // 缺点：新实例无法向父类构造函数传参。
  // 继承单一
  // 所有的实例会共享父类原型上的属性（有一个实例改了，其他的都会改）


  //  借助构造函数继承
  // function Con(){
  //     Person.call(this,'jer')
  //     this.age=21
  // }
  // let con1 = new Con()
  // console.log(con1.age,con1.name)
  // 优缺点：
  // 只继承了父类的构造函数属性，没有继承父类的原型属性
  // 可以继承多个构造函数属性
  // 在子实例中可以向父实例传参数

  // 组合式继承
  //  function Has(name){
  //      Person.call(this,name)
  //  }
  //  Has.prototype = new Person()
  //  let has = new Has('lla')
  // 优缺点：
  // 可以继承父类原型上的属性，可以传参，可以复用。
  // 每个新实例引入的构造函数属性都是私有的。
  // 调用两次父类的构造函数，消耗内存。

  // 原型式继承
  //  function Have(obj){
  //      function F(){}
  //      F.prototype = obj;
  //      return new F()
  //  }
  //  let have = new Person()
  //  let have1 = Have(have)
  //  have1.age // 10
  // 用一个函数包装一个对象，返回这个函数的调用，这个函数就变成了可以任意增添属性的实例或对象
  // 所有实例都会继承原型上的属性，无法实现复用。

  // 寄生式继承
  //  function Hee(obj){
  //      function H(){}
  //      H.prototype = obj
  //      return new H()
  //  }
  //  let hep = new Person()
  // //  let hep1 = Hee(hep)
  // function subFunc(obj){
  //     let newObj = Hee(obj)
  //     newObj.name="nana"
  //     return newObj;
  // }
  // let newnew = subFunc(hep)
  // 创建了个新对象
  // 没用到原型，无法复用。

  // 寄生组合式继承
  // function H(obj){
  //     function G(){}
  //     G.prototype=obj;
  //     return new G()
  // }
  // let Con = H(Person.prototype)
  // function Sub(){
  //     Person.call(this)
  // }
  // Sub.prototype = Con
  // Con.constructor=Sub;
  // let subb = new Sub()
  // console.log(subb.age)

  // 修复了组合式继承的问题：组合式继承是原型链继承和借助构造函数继承
  // js中继承的方法：
  // 原型链继承-借助构造函数继承-组合式继承-原型式继承-寄生式继承-寄生组合式继承-ES6extends继承

















  let obj = { a: 1, b: 2, c: 3 }
  console.log(Object.entries(obj))
  let obj2 = [1, 2, 3]
  let obj3 = [4, 5, 6]
  let obj4 = Array.from(new Set([...obj2, ...obj3]))
  let obj5 = Array.from([...obj2, ...obj3])
  console.log(obj5)
  //  var length = 10
  //       var fn1 = ()=> console.log(this.length)
  //       var fn2 = function(){
  //           console.log(this.length)
  //       }
        // var arr = [fn1, fn2]
        // fn1() //10
        // fn2() //10
        // arr[0]() //10
        // arr[1]() //2
        // var a = {n:1}
        // var b = a
        // a.x = {n:2}
        // a = {n:2}
        // console.log(a)
        // console.log('-----------------')
        // console.log(b)
  /*
      a = {
          n:2
      }
      b = {
          n:1,
          x:{n:2}
      }
  */
        // [1,7,11].map(parseInt) ==> [1, NaN, 3]
        // 1 parseInt(1, 0, [1,7,11]) 1 ** 0为false,radix为空或者false,默认为10
        // 7 parseInt(7, 1, [1,7,11]) NaN **进制1里不存在7，so 为NaN
        // 11 parseInt(11, 2, [1,7,11]) 3 **2进制里的11转成10进制是3
  // Object.assign()浅拷贝
  // Object.assign(target,source,...source),后者覆盖前者

  // setTimeout(()=>{
  //   console.log(1) 
  // },0)
  // Promise.resolve().then(()=>{
  //   console.log(2) 
  // })
  // console.log(3)
  // function add(a) {
  //   function sum(b) { 
  //     console.log(a,'a<===',b,'b<====')
  //     a = a + b; 
  //   	return sum;
  //   }
  //   sum.toString = function() { // 重写toString()方法
  //       return a;
  //   }
  //   return sum; // 返回一个函数
  // }

  // console.log(add(1))  // 1
  // console.log(add(1)(2)) // 3
  /*
  数组,对象类型判断方法
  typeof arr
  arr instanceof Array ===========谨慎使用======
  arr.constructor === Array 属性 ========谨慎使用==============
  Array.isArray(arr) === true
  Object.prototype.toString.call(obj) === '[object Array]'
  */
  // let arr = [1,2,3];
  // let obj = {a:1,b:2,c:3};
  // console.log(typeof arr,'typeof arr')
  // console.log(typeof obj,'typeof obj')
  // // ===>
  // console.log(arr instanceof Array,'arr instanceof Array')
  // console.log(obj instanceof Object,'obj instanceof Object')
  // console.log(arr.constructor === Array,'arr.constructor')
  // console.log(obj.constructor === Object,'obj.constructor')
  // // <===
  // console.log(Array.isArray(arr),'Array.isArray(arr)')
  // console.log(Array.isArray(obj),'Array.isArray(obj)')
  // console.log(Object.prototype.toString.call(arr),'Object.prototype.toString.call(arr)')
  // console.log(Object.prototype.toString.call(obj),'Object.prototype.toString.call(obj)')
  // Primise===>>>>>
  // function sleep(ms){
  //     return new Promise((resolve,reject)=>{
  //         setTimeout(function(){
  //             resolve('2000很快就过去')
  //         },ms)
  //     })
  // }
  // (async () => {
  //     console.log('hello')
  //     let res = await sleep(2000)
  //     console.log(res)
  //     console.log('world')
  // })()
  // function Cut(){
  //   console.log('begin Cut')
  //   return new Promise(function(resolve,reject){
  //     setTimeout(function(){
  //       console.log('Cut End')
  //       resolve('This is your Cut')
  //     },1000)
  //   })
  // }
  // function Boil(){
  //   console.log('begin Boil')
  //   return new Promise(function(resolve,reject){
  //     setTimeout(function(){
  //       console.log('Boil End')
  //       resolve('This is your Boil')
  //     },1000)
  //   })
  // }
  // Promise.race([Cut(),Boil()]).then(function(res){
  //   console.log('everything is ok')
  //   console.log('res=>',res)
  // }).catch(function(err){
  //   throw new Error('wrong')
  // }).finally(function(res){
  //   console.log(res,'finnally==res')
  // })
  // Promise.race([Cut(),Boil()]).then(function(res){
  //   console.log('everything is ok')
  //   console.log('res=>',res)
  // })
  // 先排序后去重
  // let array = [1, 1,'1', 5, 4, 5, 2]
  // array.sort(function(a,b){
  //   return a - b
  // })
  // console.log(array)
  // function Unique(array) {
  //   let res = []
  //   console.log(array,'array')
  //   let sortedArray = array.sort()
  //   console.log(sortedArray,'sortedArray')
  //   let seen
  //   for (let i = 0; i < sortedArray.length; i++) {
  //     // 如果是第一个元素或者相邻的元素不相同
  //     if (!i || seen !== sortedArray[i]) {
  //         res.push(sortedArray[i])
  //     }
  //     seen = sortedArray[i]
  //   }
  //   return res
  // }
  // function Unique (arr) {
  //   const seen = new Map()
  //   return arr.filter((a) => !seen.has(a) && seen.set(a, 1))
  // }

  // console.log(Unique(array))
  // let classtype = {}
  // "Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item) {
  //   classtype["[object " + item + "]"] = item.toLowerCase();
  // })
  // console.log(classtype,'classtype====')
  // 获取当前月份的最后一天
  // let month = 8
  // console.log(new Date(2019,month,0))
// Sat Aug 31 2019 00:00:00 GMT+0800 (中国标准时间)
// 数组解构赋值 否则默认值
// let arr = ['apple','orangle','bannana']
// let [firstFruit = 'lala'] = arr
// console.log(firstFruit,'============')
// 不可变赋值
// let arr1 = [ 1, 2, 3 ]
// const [ , ...firstName] = arr1
// console.log(firstName, 'firstNme')
// const big = {
//   foo:'value foo',
//   bar: 'value bar'
// }
// const { foo, ...small } = big
// console.log(small, 'small==')
// console.log(big, 'big==')
// console.log(!!'') //false
// console.log(!![]) //true
// console.log(!!null)// false
// console.log(!!undefined) //false

// let ob1={a1:1,a2:2}
// let ob2={a1:2,a3:3}
// obj={...ob1,...ob2}
// obj=Object.assign(ob1,ob2)
</script>

</html>